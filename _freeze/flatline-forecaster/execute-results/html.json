{
  "hash": "939a2383f38ad947aefa9d6577c8e081",
  "result": {
    "markdown": "# Introducing the flatline forecaster\n\nThe flatline forecaster is a very simple forecasting model intended for `epi_df` data, where the most recent observation is used as the forecast for any future date. In other words, the last observation is propagated forward. Hence, a flat line phenomenon is observed for the point predictions. The predictive intervals are produced from the quantiles of the residuals of such a forecast over all of the training data. By default, these intervals will be obtained separately for each combination of keys (`geo_value` and any additional keys) in the `epi_df`. Thus, the output is a data frame of point (and optionally interval) forecasts at a single unique horizon (`ahead`) for each unique combination of key variables. This forecaster is comparable to the baseline used by the [COVID Forecast Hub](https://covid19forecasthub.org).\n\n## Example of using the flatline forecaster\n\n### Load required packages\n\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-2_89f668bd07641a5241fbd1f9eaeba397'}\n\n```{.r .cell-code}\nlibrary(epipredict)\nlibrary(epiprocess)\n```\n:::\n\n\n### A brief introduction to the dataset\n\nWe will use the `case_death_rate_subset` dataset that comes with the `epipredict` package. In brief, this is a subset of the JHU daily COVID-19 cases and deaths by state. While this dataset ranges from Dec 31, 2020 to Dec 31, 2021, we will only consider a small subset at the end of that range to keep our example relatively simple.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-3_7e7d0aabef5e5965d214221bef209da5'}\n\n```{.r .cell-code}\njhu <- case_death_rate_subset %>%\n  dplyr::filter(time_value >= as.Date(\"2021-09-01\"))\n\njhu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 6,832 x 4 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 6,832 × 4\n#>   geo_value time_value case_rate death_rate\n#> * <chr>     <date>         <dbl>      <dbl>\n#> 1 ak        2021-09-01      75.3      0.198\n#> 2 al        2021-09-01     113.       0.845\n#> 3 ar        2021-09-01      68.5      0.919\n#> 4 as        2021-09-01       0        0    \n#> 5 az        2021-09-01      48.8      0.414\n#> 6 ca        2021-09-01      38.4      0.246\n#> # ℹ 6,826 more rows\n```\n:::\n:::\n\n\n### The basic mechanics of the flatline forecaster\n\nThe simplest to create and train a flatline forecaster to predict the death rate one week into the future, is to input the `epi_df` and the name of the column from it that we want to predict in the `flatline_forecaster` function.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-4_b7af3cd458ba646a9b72f6b0e68c31da'}\n\n```{.r .cell-code}\none_week_ahead <- flatline_forecaster(jhu, outcome = \"death_rate\")\none_week_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $predictions\n#> An `epi_df` object, 56 x 6 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 56 × 6\n#>   geo_value time_value  .pred         .pred_distn forecast_date target_date\n#> * <chr>     <date>      <dbl>              <dist> <date>        <date>     \n#> 1 ak        2021-12-31 0.0395 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> 2 al        2021-12-31 0.107  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> 3 ar        2021-12-31 0.490  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> 4 as        2021-12-31 0      [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> 5 az        2021-12-31 0.608  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> 6 ca        2021-12-31 0.142  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07 \n#> # ℹ 50 more rows\n#> \n#> $epi_workflow\n#> ══ Epi Workflow [trained] ═══════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> Postprocessor: Frosting\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 2 Recipe Steps\n#> \n#> • step_epi_ahead()\n#> • step_training_window()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> $residuals\n#> # A tibble: 7,224 × 2\n#>   geo_value .resid\n#>   <chr>      <dbl>\n#> 1 ak            NA\n#> 2 al            NA\n#> 3 ar            NA\n#> 4 as            NA\n#> 5 az            NA\n#> 6 ca            NA\n#> # ℹ 7,218 more rows\n#> \n#> $.pred\n#> # A tibble: 56 × 2\n#>   geo_value  .pred\n#>   <chr>      <dbl>\n#> 1 ak        0.0395\n#> 2 al        0.107 \n#> 3 ar        0.490 \n#> 4 as        0     \n#> 5 az        0.608 \n#> 6 ca        0.142 \n#> # ℹ 50 more rows\n#> \n#> attr(,\"class\")\n#> [1] \"flatline\"\n#> ── Postprocessor ────────────────────────────────────────────────────────────\n#> 5 Frosting Layers\n#> \n#> • layer_predict()\n#> • layer_residual_quantiles()\n#> • layer_add_forecast_date()\n#> • layer_add_target_date()\n#> • layer_threshold()\n```\n:::\n:::\n\n\nThe result is both a fitted model object which could be used any time in the future to create different forecasts, as well as a set of predicted values and prediction intervals for each location 7 days after the last available time value in the data, which is Dec 31, 2021. Note that 7 days is the default number of time steps ahead of the forecast date in which forecasts should be produced. To change this, you must change the value of the `ahead` parameter in the list of additional arguments `flatline_args_list()`. Let's change this to 5 days to get some practice.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-5_163e48cb48f59bb1fe2a9b5a1737ef01'}\n\n```{.r .cell-code}\nfive_days_ahead <- flatline_forecaster(\n  jhu, \n  outcome = \"death_rate\",\n  flatline_args_list(ahead = 5L)\n)\n\nfive_days_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $predictions\n#> An `epi_df` object, 56 x 6 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 56 × 6\n#>   geo_value time_value  .pred         .pred_distn forecast_date target_date\n#> * <chr>     <date>      <dbl>              <dist> <date>        <date>     \n#> 1 ak        2021-12-31 0.0395 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> 2 al        2021-12-31 0.107  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> 3 ar        2021-12-31 0.490  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> 4 as        2021-12-31 0      [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> 5 az        2021-12-31 0.608  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> 6 ca        2021-12-31 0.142  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-05 \n#> # ℹ 50 more rows\n#> \n#> $epi_workflow\n#> ══ Epi Workflow [trained] ═══════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> Postprocessor: Frosting\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 2 Recipe Steps\n#> \n#> • step_epi_ahead()\n#> • step_training_window()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> $residuals\n#> # A tibble: 7,112 × 2\n#>   geo_value .resid\n#>   <chr>      <dbl>\n#> 1 ak            NA\n#> 2 al            NA\n#> 3 ar            NA\n#> 4 as            NA\n#> 5 az            NA\n#> 6 ca            NA\n#> # ℹ 7,106 more rows\n#> \n#> $.pred\n#> # A tibble: 56 × 2\n#>   geo_value  .pred\n#>   <chr>      <dbl>\n#> 1 ak        0.0395\n#> 2 al        0.107 \n#> 3 ar        0.490 \n#> 4 as        0     \n#> 5 az        0.608 \n#> 6 ca        0.142 \n#> # ℹ 50 more rows\n#> \n#> attr(,\"class\")\n#> [1] \"flatline\"\n#> ── Postprocessor ────────────────────────────────────────────────────────────\n#> 5 Frosting Layers\n#> \n#> • layer_predict()\n#> • layer_residual_quantiles()\n#> • layer_add_forecast_date()\n#> • layer_add_target_date()\n#> • layer_threshold()\n```\n:::\n:::\n\n\nWe could also specify that we want a 80% predictive interval by changing the levels. The default 0.05 and 0.95 levels/quantiles give us 90% predictive interval.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-6_2e238eb1b024fe5ac9dc73c7b5275b14'}\n\n```{.r .cell-code}\nfive_days_ahead <- flatline_forecaster(\n  jhu, \n  outcome = \"death_rate\",\n  flatline_args_list(ahead = 5L, levels = c(0.1, 0.9))\n)\n\nfive_days_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $predictions\n#> An `epi_df` object, 56 x 6 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 56 × 6\n#>   geo_value time_value  .pred       .pred_distn forecast_date target_date\n#> * <chr>     <date>      <dbl>            <dist> <date>        <date>     \n#> 1 ak        2021-12-31 0.0395 [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 2 al        2021-12-31 0.107  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 3 ar        2021-12-31 0.490  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 4 as        2021-12-31 0      [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 5 az        2021-12-31 0.608  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 6 ca        2021-12-31 0.142  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> # ℹ 50 more rows\n#> \n#> $epi_workflow\n#> ══ Epi Workflow [trained] ═══════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> Postprocessor: Frosting\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 2 Recipe Steps\n#> \n#> • step_epi_ahead()\n#> • step_training_window()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> $residuals\n#> # A tibble: 7,112 × 2\n#>   geo_value .resid\n#>   <chr>      <dbl>\n#> 1 ak            NA\n#> 2 al            NA\n#> 3 ar            NA\n#> 4 as            NA\n#> 5 az            NA\n#> 6 ca            NA\n#> # ℹ 7,106 more rows\n#> \n#> $.pred\n#> # A tibble: 56 × 2\n#>   geo_value  .pred\n#>   <chr>      <dbl>\n#> 1 ak        0.0395\n#> 2 al        0.107 \n#> 3 ar        0.490 \n#> 4 as        0     \n#> 5 az        0.608 \n#> 6 ca        0.142 \n#> # ℹ 50 more rows\n#> \n#> attr(,\"class\")\n#> [1] \"flatline\"\n#> ── Postprocessor ────────────────────────────────────────────────────────────\n#> 5 Frosting Layers\n#> \n#> • layer_predict()\n#> • layer_residual_quantiles()\n#> • layer_add_forecast_date()\n#> • layer_add_target_date()\n#> • layer_threshold()\n```\n:::\n:::\n\n\nTo see the other arguments that you may modify, please see `?flatline_args_list()`. For now, we will move on to looking at the workflow.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-7_e4f7fe80f48d0e558e164a752b4ed9d6'}\n\n```{.r .cell-code}\nfive_days_ahead$epi_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> ══ Epi Workflow [trained] ═══════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> Postprocessor: Frosting\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 2 Recipe Steps\n#> \n#> • step_epi_ahead()\n#> • step_training_window()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> $residuals\n#> # A tibble: 7,112 × 2\n#>   geo_value .resid\n#>   <chr>      <dbl>\n#> 1 ak            NA\n#> 2 al            NA\n#> 3 ar            NA\n#> 4 as            NA\n#> 5 az            NA\n#> 6 ca            NA\n#> # ℹ 7,106 more rows\n#> \n#> $.pred\n#> # A tibble: 56 × 2\n#>   geo_value  .pred\n#>   <chr>      <dbl>\n#> 1 ak        0.0395\n#> 2 al        0.107 \n#> 3 ar        0.490 \n#> 4 as        0     \n#> 5 az        0.608 \n#> 6 ca        0.142 \n#> # ℹ 50 more rows\n#> \n#> attr(,\"class\")\n#> [1] \"flatline\"\n#> ── Postprocessor ────────────────────────────────────────────────────────────\n#> 5 Frosting Layers\n#> \n#> • layer_predict()\n#> • layer_residual_quantiles()\n#> • layer_add_forecast_date()\n#> • layer_add_target_date()\n#> • layer_threshold()\n```\n:::\n:::\n\n\nThe fitted model here was based on minimal pre-processing of the data, estimating a flatline model, and then post-processing the results to be meaningful for epidemiological tasks. To look deeper into the pre-processing, model and processing parts individually, you may use the `$` operator after `epi_workflow`. For example, let's examine the pre-processing part in more detail.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-8_ae9596912d577580b40055e43b1429a5'}\n\n```{.r .cell-code}\nfive_days_ahead$epi_workflow$pre\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $actions\n#> $actions$recipe\n#> $recipe\n#> \n#> $blueprint\n#> Recipe blueprint: \n#>  \n#> # Predictors: 0 \n#>   # Outcomes: 0 \n#>    Intercept: FALSE \n#> Novel Levels: FALSE \n#>  Composition: tibble \n#> \n#> attr(,\"class\")\n#> [1] \"action_recipe\" \"action_pre\"    \"action\"       \n#> \n#> \n#> $mold\n#> $mold$predictors\n#> # A tibble: 7,112 × 3\n#>   time_value geo_value death_rate\n#>   <date>     <chr>          <dbl>\n#> 1 2021-08-27 ak                NA\n#> 2 2021-08-27 al                NA\n#> 3 2021-08-27 ar                NA\n#> 4 2021-08-27 as                NA\n#> 5 2021-08-27 az                NA\n#> 6 2021-08-27 ca                NA\n#> # ℹ 7,106 more rows\n#> \n#> $mold$outcomes\n#> # A tibble: 7,112 × 1\n#>   ahead_5_death_rate\n#>                <dbl>\n#> 1              0.198\n#> 2              0.845\n#> 3              0.919\n#> 4              0    \n#> 5              0.414\n#> 6              0.246\n#> # ℹ 7,106 more rows\n#> \n#> $mold$blueprint\n#> Recipe blueprint: \n#>  \n#> # Predictors: 3 \n#>   # Outcomes: 0 \n#>    Intercept: FALSE \n#> Novel Levels: FALSE \n#>  Composition: tibble \n#> \n#> $mold$extras\n#> $mold$extras$roles\n#> $mold$extras$roles$time_value\n#> # A tibble: 7,112 × 1\n#>   time_value\n#>   <date>    \n#> 1 2021-08-27\n#> 2 2021-08-27\n#> 3 2021-08-27\n#> 4 2021-08-27\n#> 5 2021-08-27\n#> 6 2021-08-27\n#> # ℹ 7,106 more rows\n#> \n#> $mold$extras$roles$geo_value\n#> # A tibble: 7,112 × 1\n#>   geo_value\n#>   <chr>    \n#> 1 ak       \n#> 2 al       \n#> 3 ar       \n#> 4 as       \n#> 5 az       \n#> 6 ca       \n#> # ℹ 7,106 more rows\n#> \n#> $mold$extras$roles$raw\n#> # A tibble: 7,112 × 1\n#>   case_rate\n#>       <dbl>\n#> 1        NA\n#> 2        NA\n#> 3        NA\n#> 4        NA\n#> 5        NA\n#> 6        NA\n#> # ℹ 7,106 more rows\n#> \n#> \n#> \n#> \n#> $case_weights\n#> NULL\n#> \n#> attr(,\"class\")\n#> [1] \"stage_pre\" \"stage\"\n```\n:::\n:::\n\n\nUnder Operations, we can see that the pre-processing operations were to lead the death rate by 5 days (`step_epi_ahead()`) and that the \\# of recent observations used in the training window were not limited (in `step_training_window()` as `n_training = Inf` in `flatline_args_list()`). You should also see the molded/pre-processed training data.\n\nFor symmetry, let's have a look at the post-processing.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-9_8cdc131b600e2e193762d72749a4c485'}\n\n```{.r .cell-code}\nfive_days_ahead$epi_workflow$post\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $actions\n#> $actions$frosting\n#> $frosting\n#> \n#> attr(,\"class\")\n#> [1] \"action_post\" \"action\"     \n#> \n#> \n#> attr(,\"class\")\n#> [1] \"stage_post\" \"stage\"\n```\n:::\n:::\n\n\nThe post-processing operations in the order the that were performed were to create the predictions and the predictive intervals, add the forecast and target dates and bound the predictions at zero.\n\nWe can also easily examine the predictions themselves.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-10_30f3bcf889ce520b19643ffe5f7cd3b9'}\n\n```{.r .cell-code}\nfive_days_ahead$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 56 x 6 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 56 × 6\n#>   geo_value time_value  .pred       .pred_distn forecast_date target_date\n#> * <chr>     <date>      <dbl>            <dist> <date>        <date>     \n#> 1 ak        2021-12-31 0.0395 [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 2 al        2021-12-31 0.107  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 3 ar        2021-12-31 0.490  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 4 as        2021-12-31 0      [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 5 az        2021-12-31 0.608  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 6 ca        2021-12-31 0.142  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> # ℹ 50 more rows\n```\n:::\n:::\n\n\nThe results above show a distributional forecast produced using data through the end of 2021 for the January 5, 2022. A prediction for the death rate per 100K inhabitants along with a 95% predictive interval is available for every state (`geo_value`).\n\nThe figure below displays the prediction and prediction interval for three sample states: Arizona, New York, and Florida.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-11_2188c6ce329601f70b1d9bfde2bc33f7'}\n\n```{.r .cell-code  code-fold=\"true\"}\nsamp_geos <- c(\"az\", \"ny\", \"fl\")\n\nhist <- jhu %>% \n  filter(geo_value %in% samp_geos)\n\npreds <- five_days_ahead$predictions %>% \n  filter(geo_value %in% samp_geos) %>% \n  mutate(q = nested_quantiles(.pred_distn)) %>% \n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n\nggplot(hist, aes(color = geo_value)) +\n  geom_line(aes(time_value, death_rate)) +\n  theme_bw() +\n  geom_errorbar(data = preds, aes(x = target_date, ymin = `0.1`, ymax = `0.9`)) +\n  geom_point(data = preds, aes(target_date, .pred)) +\n  geom_vline(data = preds, aes(xintercept = forecast_date)) +\n  scale_colour_viridis_d(name = \"\") +\n  scale_x_date(date_labels = \"%b %Y\", date_breaks = \"1 month\") +\n  facet_grid(geo_value ~ ., scales = \"free_y\") +\n  theme(legend.position = \"none\") +\n  labs(x = \"\", y = \"Incident deaths per 100K\\n inhabitants\") \n```\n\n::: {.cell-output-display}\n![](flatline-forecaster_files/figure-html/unnamed-chunk-11-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nThe vertical black line is the forecast date. Here the forecast seems pretty reasonable based on the past observations shown. In cases where the recent past is highly predictive of the near future, a simple flatline forecast may be respectable, but in more complex situations where there is more uncertainty of what's to come, the flatline forecaster may be best relegated to being a baseline model and nothing more.\n\nTake for example what happens when we consider a wider range of target dates. That is, we will now predict for several different horizons or `ahead` values - in our case, 5 to 25 days ahead, inclusive. Since the flatline forecaster function forecasts at a single unique `ahead` value, we can use the `map()` function from `purrr` to apply the forecaster to each ahead value we want to use. Then, we row bind the list of results.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-12_6c29d89781f5b2499c5587c9183d39d9'}\n\n```{.r .cell-code}\nout_df <- purrr::map(\n  1:28, \n  ~ flatline_forecaster(\n      jhu, \n      outcome = \"death_rate\",\n      args_list = flatline_args_list(ahead = .x)\n    )$predictions\n  ) %>% \n  list_rbind()\n```\n:::\n\n\nThen, we proceed as we did before. The only difference from before is that we're using `out_df` where we had `five_days_ahead$predictions`.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-13_72c386fe087f4abccfe330013fa504b4'}\n\n```{.r .cell-code  code-fold=\"true\"}\npreds <- out_df %>% \n  filter(geo_value %in% samp_geos) %>% \n  mutate(q = nested_quantiles(.pred_distn)) %>% \n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n\nggplot(hist) +\n  geom_line(aes(time_value, death_rate)) +\n  geom_ribbon(\n    data = preds, \n    aes(x = target_date, ymin = `0.05`, ymax = `0.95`, fill = geo_value)) +\n  geom_point(data = preds, aes(target_date, .pred, colour = geo_value)) +\n  geom_vline(data = preds, aes(xintercept = forecast_date)) +\n  scale_colour_viridis_d() +\n  scale_fill_viridis_d(alpha = .4) +\n  scale_x_date(date_labels = \"%b %Y\", date_breaks = \"1 month\") +\n  scale_y_continuous(expand = expansion(c(0, .05))) +\n  facet_grid(geo_value ~ ., scales = \"free_y\") +\n  labs(x = \"\", y = \"Incident deaths per 100K\\n inhabitants\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](flatline-forecaster_files/figure-html/unnamed-chunk-13-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nNow, you can really see the flat line trend in the predictions. And you may also observe that as we get further away from the forecast date, the more unnerving using a flatline prediction becomes. It feels increasingly unnatural.\n\nSo naturally the choice of forecaster relates to the time frame being considered. In general, using a flatline forecaster makes more sense for short-term forecasts than for long-term forecasts and for periods of great stability than in less stable times. Realistically, periods of great stability are rare. Moreover, in our model of choice we want to take into account more information about the past than just what happened at the most recent time point. So simple forecasters like the flatline forecaster don't cut it as actual contenders in many real-life situations. However, they are not useless, just used for a different purpose. A simple model is often used to compare a more complex model to, which is why you may have seen such a model used as a baseline in the [COVID Forecast Hub](https://covid19forecasthub.org). The following [blog post](https://delphi.cmu.edu/blog/2021/09/30/on-the-predictability-of-covid-19/#ensemble-forecast-performance) from Delphi explores the Hub's ensemble accuracy relative to such a baseline model.\n\n## What we've learned in a nutshell\n\nThough the flatline forecaster is a very basic model with limited customization, it is about as steady and predictable as a model can get. So it provides a good reference or baseline to compare more complicated models to.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}